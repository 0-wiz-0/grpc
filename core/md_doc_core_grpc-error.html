<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GRPC Core: gRPC Error</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">gRPC Error </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Background</h2>
<p><code>grpc_error</code> is the c-core's opaque representation of an error. It holds a collection of integers, strings, timestamps, and child errors that related to the final error.</p>
<p>always present are:</p>
<ul>
<li>GRPC_ERROR_STR_FILE and GRPC_ERROR_INT_FILE_LINE - the source location where the error was generated</li>
<li>GRPC_ERROR_STR_DESCRIPTION - a human readable description of the error</li>
<li>GRPC_ERROR_TIME_CREATED - a timestamp indicating when the error happened</li>
</ul>
<p>An error can also have children; these are other errors that are believed to have contributed to this one. By accumulating children, we can begin to root cause high level failures from low level failures, without having to derive execution paths from log lines.</p>
<p>grpc_errors are refcounted objects, which means they need strict ownership semantics. An extra ref on an error can cause a memory leak, and a missing ref can cause a crash.</p>
<p>This document serves as a detailed overview of grpc_error's ownership rules. It should help people use the errors, as well as help people debug refcount related errors.</p>
<h2>Clarification of Ownership</h2>
<p>If a particular function is said to "own" an error, that means it has the responsibility of calling unref on the error. A function may have access to an error without ownership of it.</p>
<p>This means the function may use the error, but must not call unref on it, since that will be done elsewhere in the code. A function that does not own an error may explicitly take ownership of it by manually calling GRPC_ERROR_REF.</p>
<h2>Ownership Rules</h2>
<p>There are three rules of error ownership, which we will go over in detail.</p>
<ul>
<li>If <code>grpc_error</code> is returned by a function, the caller owns a ref to that instance.</li>
<li>If a <code>grpc_error</code> is passed to a <code>grpc_closure</code> callback function, then that function does not own a ref to the error.</li>
<li>if a <code>grpc_error</code> is passed to <em>any other function</em>, then that function takes ownership of the error.</li>
</ul>
<h3>Rule 1</h3>
<blockquote class="doxtable">
<p>If <code>grpc_error</code> is returned by a function, the caller owns a ref to that instance.*</p>
<p></p>
</blockquote>
<p>For example, in the following code block, error1 and error2 are owned by the current function.</p>
<p>```C grpc_error* error1 = GRPC_ERROR_CREATE_FROM_STATIC_STRING("Some error occured"); grpc_error* error2 = some_operation_that_might_fail(...); ```</p>
<p>The current function would have to explicitly call GRPC_ERROR_UNREF on the errors, or pass them along to a function that would take over the ownership.</p>
<h3>Rule 2</h3>
<blockquote class="doxtable">
<p>If a <code>grpc_error</code> is passed to a <code>grpc_closure</code> callback function, then that function does not own a ref to the error.</p>
<p></p>
</blockquote>
<p>A <code>grpc_closure</code> callback function is any function that has the signature:</p>
<p>```C void (*cb)(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error); ```</p>
<p>This means that the error ownership is NOT transferred when a functions calls:</p>
<p>```C c-&gt;cb(exec_ctx, c-&gt;cb_arg, err); ```</p>
<p>The caller is still responsible for unref-ing the error.</p>
<p>However, the above line is currently being phased out! It is safer to invoke callbacks with <code>grpc_closure_run</code> and <code>grpc_closure_sched</code>. These functions are not callbacks, so they will take ownership of the error passed to them.</p>
<p>```C grpc_error* error = GRPC_ERROR_CREATE_FROM_STATIC_STRING("Some error occured"); grpc_closure_run(exec_ctx, cb, error); // current function no longer has ownership of the error ```</p>
<p>If you schedule or run a closure, but still need ownership of the error, then you must explicitly take a reference.</p>
<p>```C grpc_error* error = GRPC_ERROR_CREATE_FROM_STATIC_STRING("Some error occured"); grpc_closure_run(exec_ctx, cb, GRPC_ERROR_REF(error)); // do some other things with the error GRPC_ERROR_UNREF(error); ```</p>
<p>Rule 2 is more important to keep in mind when <b>implementing</b> <code>grpc_closure</code> callback functions. You must keep in mind that you do not own the error, and must not unref it. More importantly, you cannot pass it to any function that would take ownership of the error, without explicitly taking ownership yourself. For example:</p>
<p>```C void on_some_action(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) { // this would cause a crash, because some_function will unref the error, // and the caller of this callback will also unref it. some_function(error);</p>
<p>// this callback function must take ownership, so it can give that // ownership to the function it is calling. some_function(GRPC_ERROR_REF(error)); } ```</p>
<h3>Rule 3</h3>
<blockquote class="doxtable">
<p>if a <code>grpc_error</code> is passed to <em>any other function</em>, then that function takes ownership of the error.</p>
<p></p>
</blockquote>
<p>Take the following example:</p>
<p>```C grpc_error* error = GRPC_ERROR_CREATE_FROM_STATIC_STRING("Some error occured"); // do some things some_function(error); // can't use error anymore! might be gone. ```</p>
<p>When some_function is called, it takes over the ownership of the error, and it will eventually unref it. So the caller can no longer safely use the error.</p>
<p>If the caller needed to keep using the error (or passing it to other functions), if would have to take on a reference to it. This is a common pattern seen.</p>
<p>```C void func() { grpc_error* error = GRPC_ERROR_CREATE_FROM_STATIC_STRING("Some error"); some_function(GRPC_ERROR_REF(error)); // do things some_other_function(GRPC_ERROR_REF(error)); // do more things some_last_function(error); } ```</p>
<p>The last call takes ownership and will eventually give the error its final unref.</p>
<p>When <b>implementing</b> a function that takes an error (and is not a <code>grpc_closure</code> callback function), you must ensure the error is unref-ed either by doing it explicitly with GRPC_ERROR_UNREF, or by passing the error to a function that takes over the ownership. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 27 2017 17:26:12 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
