<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: grpc::experimental::InterceptorBatchMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc.html">grpc</a></li><li class="navelem"><a class="el" href="namespacegrpc_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html">InterceptorBatchMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc::experimental::InterceptorBatchMethods Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that is passed as an argument to the <em>Intercept</em> method of the application's <em><a class="el" href="classgrpc_1_1experimental_1_1_interceptor.html" title="Interface for an interceptor. ">Interceptor</a></em> interface implementation.  
 <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="impl_2codegen_2interceptor_8h_source.html">interceptor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55f28c464881763e44c003ad945395a5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a55f28c464881763e44c003ad945395a5">~InterceptorBatchMethods</a> ()</td></tr>
<tr class="separator:a55f28c464881763e44c003ad945395a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68758f2d57120220e53bcc6ad1bc8c71"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a68758f2d57120220e53bcc6ad1bc8c71">QueryInterceptionHookPoint</a> (<a class="el" href="namespacegrpc_1_1experimental.html#a03d3481b2c4146f53e90966d4a0fd8a1">InterceptionHookPoints</a> type)=0</td></tr>
<tr class="memdesc:a68758f2d57120220e53bcc6ad1bc8c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current batch has an interception hook point of type <em>type</em>.  <a href="#a68758f2d57120220e53bcc6ad1bc8c71">More...</a><br /></td></tr>
<tr class="separator:a68758f2d57120220e53bcc6ad1bc8c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640e84ae950a57b875b38de6ef9d87fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a640e84ae950a57b875b38de6ef9d87fe">Proceed</a> ()=0</td></tr>
<tr class="memdesc:a640e84ae950a57b875b38de6ef9d87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that the interceptor is done intercepting the current batch of the RPC.  <a href="#a640e84ae950a57b875b38de6ef9d87fe">More...</a><br /></td></tr>
<tr class="separator:a640e84ae950a57b875b38de6ef9d87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#aea0a9629eb5c5aa8760d5a02fd2ef37f">Hijack</a> ()=0</td></tr>
<tr class="memdesc:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the interceptor has hijacked the RPC (only valid if the batch contains send_initial_metadata on the client side).  <a href="#aea0a9629eb5c5aa8760d5a02fd2ef37f">More...</a><br /></td></tr>
<tr class="separator:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b93c5fc95a699f52eb98dcb5e7e36e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a15b93c5fc95a699f52eb98dcb5e7e36e">GetSendMessage</a> ()=0</td></tr>
<tr class="memdesc:a15b93c5fc95a699f52eb98dcb5e7e36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifable <a class="el" href="classgrpc_1_1_byte_buffer.html" title="A sequence of bytes. ">ByteBuffer</a> holding the serialized form of the message that is going to be sent.  <a href="#a15b93c5fc95a699f52eb98dcb5e7e36e">More...</a><br /></td></tr>
<tr class="separator:a15b93c5fc95a699f52eb98dcb5e7e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf0466aa5e7827ba465e8e23aee89b"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>, <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a0ccf0466aa5e7827ba465e8e23aee89b">GetSendInitialMetadata</a> ()=0</td></tr>
<tr class="memdesc:a0ccf0466aa5e7827ba465e8e23aee89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the initial metadata to be sent.  <a href="#a0ccf0466aa5e7827ba465e8e23aee89b">More...</a><br /></td></tr>
<tr class="separator:a0ccf0466aa5e7827ba465e8e23aee89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2792ab543f8b46262ee6e69289b436ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a2792ab543f8b46262ee6e69289b436ab">GetSendStatus</a> ()=0</td></tr>
<tr class="memdesc:a2792ab543f8b46262ee6e69289b436ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status to be sent. Valid for PRE_SEND_STATUS interceptions.  <a href="#a2792ab543f8b46262ee6e69289b436ab">More...</a><br /></td></tr>
<tr class="separator:a2792ab543f8b46262ee6e69289b436ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541b5d8a424e703d562a32c27488ccf2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a541b5d8a424e703d562a32c27488ccf2">ModifySendStatus</a> (const <a class="el" href="classgrpc_1_1_status.html">Status</a> &amp;status)=0</td></tr>
<tr class="memdesc:a541b5d8a424e703d562a32c27488ccf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the status with <em>status</em>.  <a href="#a541b5d8a424e703d562a32c27488ccf2">More...</a><br /></td></tr>
<tr class="separator:a541b5d8a424e703d562a32c27488ccf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ae91237f0ab16e1bbf7e748cf7cf42"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>, <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#aa6ae91237f0ab16e1bbf7e748cf7cf42">GetSendTrailingMetadata</a> ()=0</td></tr>
<tr class="memdesc:aa6ae91237f0ab16e1bbf7e748cf7cf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the trailing metadata to be sent.  <a href="#aa6ae91237f0ab16e1bbf7e748cf7cf42">More...</a><br /></td></tr>
<tr class="separator:aa6ae91237f0ab16e1bbf7e748cf7cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b267515d6afd29afadba454aa913505"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a3b267515d6afd29afadba454aa913505">GetRecvMessage</a> ()=0</td></tr>
<tr class="memdesc:a3b267515d6afd29afadba454aa913505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the modifiable received message.  <a href="#a3b267515d6afd29afadba454aa913505">More...</a><br /></td></tr>
<tr class="separator:a3b267515d6afd29afadba454aa913505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f123307653591e63ded55d8cea9ad8b"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a8f123307653591e63ded55d8cea9ad8b">GetRecvInitialMetadata</a> ()=0</td></tr>
<tr class="memdesc:a8f123307653591e63ded55d8cea9ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the received initial metadata.  <a href="#a8f123307653591e63ded55d8cea9ad8b">More...</a><br /></td></tr>
<tr class="separator:a8f123307653591e63ded55d8cea9ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60304da4f2c2737bcc259bac19e858d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#ac60304da4f2c2737bcc259bac19e858d">GetRecvStatus</a> ()=0</td></tr>
<tr class="memdesc:ac60304da4f2c2737bcc259bac19e858d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable view of the received status on POST_RECV_STATUS interceptions; nullptr if not valid.  <a href="#ac60304da4f2c2737bcc259bac19e858d">More...</a><br /></td></tr>
<tr class="separator:ac60304da4f2c2737bcc259bac19e858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661e6372647f1639783b046d728599fa"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a661e6372647f1639783b046d728599fa">GetRecvTrailingMetadata</a> ()=0</td></tr>
<tr class="memdesc:a661e6372647f1639783b046d728599fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the received trailing metadata on POST_RECV_STATUS interceptions; nullptr if not valid.  <a href="#a661e6372647f1639783b046d728599fa">More...</a><br /></td></tr>
<tr class="separator:a661e6372647f1639783b046d728599fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993f12c0d1a9e5dce038b66c58728e82"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classgrpc_1_1_channel_interface.html">ChannelInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a993f12c0d1a9e5dce038b66c58728e82">GetInterceptedChannel</a> ()=0</td></tr>
<tr class="memdesc:a993f12c0d1a9e5dce038b66c58728e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an intercepted channel.  <a href="#a993f12c0d1a9e5dce038b66c58728e82">More...</a><br /></td></tr>
<tr class="separator:a993f12c0d1a9e5dce038b66c58728e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that is passed as an argument to the <em>Intercept</em> method of the application's <em><a class="el" href="classgrpc_1_1experimental_1_1_interceptor.html" title="Interface for an interceptor. ">Interceptor</a></em> interface implementation. </p>
<p>It has five purposes:</p><ol type="1">
<li>Indicate which hook points are present at a specific interception</li>
<li>Allow an interceptor to inform the library that an RPC should continue to the next stage of its processing (which may be another interceptor or the main path of the library)</li>
<li>Allow an interceptor to hijack the processing of the RPC (only for client-side RPCs with PRE_SEND_INITIAL_METADATA) so that it does not proceed with normal processing beyond that stage</li>
<li>Access the relevant fields of an RPC at each interception point</li>
<li>Set some fields of an RPC at each interception point, when possible </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a55f28c464881763e44c003ad945395a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f28c464881763e44c003ad945395a5">&#9670;&nbsp;</a></span>~InterceptorBatchMethods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc::experimental::InterceptorBatchMethods::~InterceptorBatchMethods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a993f12c0d1a9e5dce038b66c58728e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993f12c0d1a9e5dce038b66c58728e82">&#9670;&nbsp;</a></span>GetInterceptedChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classgrpc_1_1_channel_interface.html">ChannelInterface</a>&gt; grpc::experimental::InterceptorBatchMethods::GetInterceptedChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an intercepted channel. </p>
<p>When a call is started on this interceptor, only interceptors after the current interceptor are created from the factory objects registered with the channel. This allows calls to be started from interceptors without infinite regress through the interceptor list. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a5103bca2f3826d43182436e3e736bd7b">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a1e23ff14548292c4ae13e383d0232800">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a8f123307653591e63ded55d8cea9ad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f123307653591e63ded55d8cea9ad8b">&#9670;&nbsp;</a></span>GetRecvInitialMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetRecvInitialMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the received initial metadata. </p>
<p>Valid for POST_RECV_INITIAL_METADATA interceptions; nullptr if not valid </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a1f7cb8407197de0a0d179ed94d1d5b25">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a74068ad08786cda92a3c53d8561c6646">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a3b267515d6afd29afadba454aa913505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b267515d6afd29afadba454aa913505">&#9670;&nbsp;</a></span>GetRecvMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* grpc::experimental::InterceptorBatchMethods::GetRecvMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the modifiable received message. </p>
<p>Note that the message is already deserialized but the type is not set; the interceptor should static_cast to the appropriate type before using it. This is valid for POST_RECV_MESSAGE interceptions; nullptr for not valid </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a12909a13d7cecdceeffc794c06ff6896">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a4f8a66ad270d639eec1228205c4bc812">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="ac60304da4f2c2737bcc259bac19e858d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60304da4f2c2737bcc259bac19e858d">&#9670;&nbsp;</a></span>GetRecvStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a>* grpc::experimental::InterceptorBatchMethods::GetRecvStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable view of the received status on POST_RECV_STATUS interceptions; nullptr if not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a3ce51320fa84af6b2a00815305257b4e">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a37e9cdd09aa90c5c54eb5ba3387d179d">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a661e6372647f1639783b046d728599fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661e6372647f1639783b046d728599fa">&#9670;&nbsp;</a></span>GetRecvTrailingMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetRecvTrailingMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the received trailing metadata on POST_RECV_STATUS interceptions; nullptr if not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a4dc85e0f1a3cdb0c95f04994d443f81f">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#afe82d67dfd4604d3e97c5fa12392058d">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a0ccf0466aa5e7827ba465e8e23aee89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccf0466aa5e7827ba465e8e23aee89b">&#9670;&nbsp;</a></span>GetSendInitialMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>, <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetSendInitialMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the initial metadata to be sent. </p>
<p>Valid for PRE_SEND_INITIAL_METADATA interceptions. A value of nullptr indicates that this field is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#aeb89be1a0a160c39a1e6bf94429d5b10">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#adc297879e70dbafe36fbad92fc074bd3">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a15b93c5fc95a699f52eb98dcb5e7e36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b93c5fc95a699f52eb98dcb5e7e36e">&#9670;&nbsp;</a></span>GetSendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_byte_buffer.html">ByteBuffer</a>* grpc::experimental::InterceptorBatchMethods::GetSendMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifable <a class="el" href="classgrpc_1_1_byte_buffer.html" title="A sequence of bytes. ">ByteBuffer</a> holding the serialized form of the message that is going to be sent. </p>
<p>Valid for PRE_SEND_MESSAGE interceptions. A return value of nullptr indicates that this <a class="el" href="classgrpc_1_1_byte_buffer.html" title="A sequence of bytes. ">ByteBuffer</a> is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#ababe0a8a54704e1556403ac8d1a848e1">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#ada3c2ab7c1aee32e2b93477ed8a0ca80">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a2792ab543f8b46262ee6e69289b436ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2792ab543f8b46262ee6e69289b436ab">&#9670;&nbsp;</a></span>GetSendStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a> grpc::experimental::InterceptorBatchMethods::GetSendStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the status to be sent. Valid for PRE_SEND_STATUS interceptions. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a847d3514928d17070c30430fcbf9630c">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a2973701f908f54161019ab84451a08b5">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="aa6ae91237f0ab16e1bbf7e748cf7cf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ae91237f0ab16e1bbf7e748cf7cf42">&#9670;&nbsp;</a></span>GetSendTrailingMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>, <a class="el" href="namespacegrpc.html#ab04a87625da3bf85cdaf5e7856b00203">grpc::string</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetSendTrailingMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the trailing metadata to be sent. </p>
<p>Valid for PRE_SEND_STATUS interceptions. A value of nullptr indicates that this field is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a4d1a0a5461cbc9173cffd81fe0c8b80d">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a375ebbb919a41bc8348697a2a812ec8e">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="aea0a9629eb5c5aa8760d5a02fd2ef37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0a9629eb5c5aa8760d5a02fd2ef37f">&#9670;&nbsp;</a></span>Hijack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::Hijack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate that the interceptor has hijacked the RPC (only valid if the batch contains send_initial_metadata on the client side). </p>
<p>Later interceptors in the interceptor list will not be called. Later batches on the same RPC will go through interception, but only up to the point of the hijacking interceptor. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a4ffe4ff4ddbecd1f3b735d25fc99b028">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#ae8fab5a87b44a734e6c627bfaebfde95">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a541b5d8a424e703d562a32c27488ccf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541b5d8a424e703d562a32c27488ccf2">&#9670;&nbsp;</a></span>ModifySendStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::ModifySendStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrpc_1_1_status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the status with <em>status</em>. </p>
<p>Valid for PRE_SEND_STATUS interceptions. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a05b4170713f592382e8008bc0a9c5f06">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a5a559be4bbe86452fbb1ecd77141b0f8">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a640e84ae950a57b875b38de6ef9d87fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640e84ae950a57b875b38de6ef9d87fe">&#9670;&nbsp;</a></span>Proceed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::Proceed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal that the interceptor is done intercepting the current batch of the RPC. </p>
<p>Every interceptor must either call Proceed or Hijack on each interception. In most cases, only Proceed will be used. Explicit use of Proceed is what enables interceptors to delay the processing of RPCs while they perform other work. Proceed is a no-op if the batch contains PRE_SEND_CANCEL. Simply returning from the Intercept method does the job of continuing the RPC in this case. This is because PRE_SEND_CANCEL is always in a separate batch and is not allowed to be delayed. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#ae54b9b17705512879fd05fa7c6ca57db">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a37bf16655256d3f296a6ca04eafed0bd">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a68758f2d57120220e53bcc6ad1bc8c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68758f2d57120220e53bcc6ad1bc8c71">&#9670;&nbsp;</a></span>QueryInterceptionHookPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc::experimental::InterceptorBatchMethods::QueryInterceptionHookPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegrpc_1_1experimental.html#a03d3481b2c4146f53e90966d4a0fd8a1">InterceptionHookPoints</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the current batch has an interception hook point of type <em>type</em>. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#ab5efa6c1ab93ca3a5ee46cff63f87b76">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a0093ac4ad56f3d8e96c87545f29329a1">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpcpp/impl/codegen/<a class="el" href="impl_2codegen_2interceptor_8h_source.html">interceptor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 18 2019 16:38:52 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
